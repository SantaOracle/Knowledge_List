## 1.什么是事务？ ##

&nbsp;&nbsp;简洁明了的定义：事务，是一系列操作，并且这些操作需要符合ACID特性。

&nbsp;&nbsp;同一事务中的操作，要么全部成功，要么全部失败

## 2.事务的特性？ ##

&nbsp;&nbsp;ACID

&nbsp;&nbsp;A —— Atomicity，原子性：也就是，所有操作，要么全部成功，要么全部失败

&nbsp;&nbsp;C —— Consistency，一致性：系统（数据库）总会从一种状态，变化到另一种状态，不存在中间状态

&nbsp;&nbsp;I —— Isolation，隔离性：通常来说，一个事务在完全提交之前，对其他事务是不可见的（取决于隔离等级）

&nbsp;&nbsp;D —— Durability，持久性：一旦事务提交，那么对应的数据就定下来了，即时机器宕机也不影响到这个事务的结果

## 3.同时有多个事务，会怎样，怎么解决这些问题？ ##

&nbsp;&nbsp;单线程情况下，即使有多个事务，也不会怎么样，问题主要出现在多线程处理多事务的情况。

&nbsp;&nbsp;理论上，每提升一种隔离机制，就可以多解决一块问题。在这里，我们把出现的问题和该问题在哪个隔离机制下解决，用一个表格列一下：

解决的问题名称 | 问题描述 |  隔离机制 | 隔离机制描述  
-|-|-|-
- | - | 未提交读 | 没有任何限制，所有数据在任意时刻都能被任意事务进行读写
脏读 | A事务读取到了B事务未提交的内容，之后B事务进行了回滚 | 已提交读 | 其他事务只能读取到本事务已经提交的部分。
不可重复读 | A事务只能读取B事务已提交的部分，这会造成A事务内两次查询，结果可能会不一样，因为B事务在A第一次读取后进行了提交 | 可重复读 | 在A事务结束前，涉及到的数据，无论A事务是否修改该数据，其他事务都不允许进行修改
幻读 | 事务A读取某一段的数据，此时事务B新增了一条数据，导致事务A没有获取到这条新数据 | 序列化 | 所有事务串行执行，不会出现任何并发事故

## 4.实现这些隔离机制的原理，能说说吗？ ##

&nbsp;&nbsp;主要是对数据上锁，锁的类型包括：

- 共享锁 —— 对某一范围的数据上锁时，其他线程（事务）能够对同样的数据上共享锁并进行读取，但是不能修改
- 排他锁 —— 对某一范围的数据上锁时，其他线程（事务）不允许对同样的数据上锁和访问以及修改

&nbsp;&nbsp;一般，共享锁我们成为读锁，排他锁我们称为写锁。

&nbsp;&nbsp;锁的粒度，取决于具体的存储引擎。InnoDB实现了行级锁，页级锁，表级锁。